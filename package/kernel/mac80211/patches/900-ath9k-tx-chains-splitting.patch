From 6282687366469f0662ff42b0e326437d3db7fe08 Mon Sep 17 00:00:00 2001
From: Santiago Piccinini <spiccinini@altermundi.net>
Date: Sat, 7 Dec 2013 03:20:50 -0300
Subject: [PATCH 2/2] First version of tx chains spliting

---
 drivers/net/wireless/ath/ath9k/ath9k.h |  1 +
 drivers/net/wireless/ath/ath9k/xmit.c  | 13 +++++++-
 include/net/mac80211.h                 | 13 ++++++++
 net/mac80211/debugfs.c                 |  2 ++
 net/mac80211/ieee80211_i.h             |  2 ++
 net/mac80211/main.c                    |  1 +
 net/mac80211/rx.c                      |  2 ++
 net/mac80211/sta_info.h                |  1 +
 net/mac80211/tx.c                      | 57 ++++++++++++++++++++++++++++++++++
 9 files changed, 91 insertions(+), 1 deletion(-)

diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
index 3aac4b7..fea1009 100644
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -234,6 +234,7 @@ struct ath_buf {
 	dma_addr_t bf_buf_addr;	/* physical addr of data buffer, for DMA */
 	struct ieee80211_tx_rate rates[4];
 	struct ath_buf_state bf_state;
+	u8 chainmask_override;
 };
 
 struct ath_atx_tid {
diff --git a/drivers/net/wireless/ath/ath9k/xmit.c b/drivers/net/wireless/ath/ath9k/xmit.c
index ee829b0..21c77ca 100644
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -145,8 +145,19 @@ static void ath_send_bar(struct ath_atx_tid *tid, u16 seqno)
 static void ath_set_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta,
 			  struct ath_buf *bf)
 {
+	struct ath_node *an = NULL;
+
 	ieee80211_get_tx_rates(vif, sta, bf->bf_mpdu, bf->rates,
 			       ARRAY_SIZE(bf->rates));
+	if(sta){
+		an = (struct ath_node *)sta->drv_priv;
+		if(bf && an){
+			bf->chainmask_override = ieee80211_get_tx_chainmask(vif, sta, bf->bf_mpdu);
+			if(printk_ratelimit()){
+				printk("station [%pM] chainmask override: 0x%02X\n", sta->addr, bf->chainmask_override);
+			}
+		}
+	}
 }
 
 static void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq,
@@ -1150,7 +1161,7 @@ static void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf,
 			/* MCS rates */
 			info->rates[i].Rate = rix | 0x80;
 			info->rates[i].ChSel = ath_txchainmask_reduction(sc,
-					ah->txchainmask, info->rates[i].Rate);
+					bf->chainmask_override, info->rates[i].Rate);
 			info->rates[i].PktDuration = ath_pkt_duration(sc, rix, len,
 				 is_40, is_sgi, is_sp);
 			if (rix < 8 && (tx_info->flags & IEEE80211_TX_CTL_STBC))
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index bcff87d..5c5b288 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -3237,6 +3237,19 @@ void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
 			    int max_rates);
 
 /**
+ * ieee80211_get_tx_chainmask - get the transmit chainmask for a packet
+ *
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @sta: the receiver station to which this packet is sent.
+ * @skb: the frame to be transmitted.
+ *
+ * Return: bitmask of transmit chains
+ */
+u8 ieee80211_get_tx_chainmask(struct ieee80211_vif *vif,
+				struct ieee80211_sta *sta,
+				struct sk_buff *skb);
+
+/**
  * ieee80211_tx_status - transmit status callback
  *
  * Call this function for all transmitted frames after they have been
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 2a45cce..a05f655 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -252,6 +252,8 @@ void debugfs_hw_add(struct ieee80211_local *local)
 	DEBUGFS_ADD(user_power);
 	DEBUGFS_ADD(power);
 
+	debugfs_create_u8("split_txchains_treshold", 0600, phyd, &local->split_txchains_treshold);
+
 	statsd = debugfs_create_dir("statistics", phyd);
 
 	/* if the dir failed, don't put all the other things into the root! */
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 47edc70..686b1f6 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1132,6 +1132,8 @@ struct ieee80211_local {
 	int user_power_level; /* in dBm, for all interfaces */
 	int user_antenna_gain; /* in dBi */
 
+	u8 split_txchains_treshold; /* in dB */
+
 	enum ieee80211_smps_mode smps_mode;
 
 	struct work_struct restart_work;
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index d469307..f89e9fe 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -612,6 +612,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
 	local->user_antenna_gain = 0;
+	local->split_txchains_treshold = 0;
 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 8f2c97c..9930a94 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1441,6 +1441,8 @@ ieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)
 			if (!(status->chains & BIT(i)))
 				continue;
 
+			sta->tx_chains |= BIT(i);
+
 			sta->chain_signal_last[i] = signal;
 			ewma_add(&sta->chain_signal_avg[i], -signal);
 		}
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index b2abd3f..035b8da 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -350,6 +350,7 @@ struct sta_info {
 	u8 chains;
 	s8 chain_signal_last[IEEE80211_MAX_CHAINS];
 	struct ewma chain_signal_avg[IEEE80211_MAX_CHAINS];
+	u8 tx_chains;
 
 	/* Plus 1 for non-QoS frames */
 	__le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 3801959..0b3a0e3 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2817,3 +2817,60 @@ void __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,
 	ieee80211_xmit(sdata, skb, band);
 	local_bh_enable();
 }
+
+
+u8 ieee80211_get_tx_chainmask(struct ieee80211_vif *vif,
+				struct ieee80211_sta *pubsta,
+				struct sk_buff *skb)
+{
+	int i;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+	struct ieee80211_local *local;
+	s8 max_signal = -128;
+	u8 max_signal_chain;
+	u8 result_chainmask;
+
+	if (!vif)
+		return;
+
+	sdata = vif_to_sdata(vif);
+	local = sdata->local;
+
+	sta = sta_info_get(sdata, pubsta->addr);
+
+	if (sta && sta->chains){
+		result_chainmask = sta->chains;
+		if(printk_ratelimit()){
+			printk(KERN_DEBUG "ieee80211_get_tx_chainmask. Total Chains: %d",  sta->chains);
+		}
+		if (local->split_txchains_treshold){
+			// search max chain
+			for (i = 0; i < IEEE80211_MAX_CHAINS; i++) {
+				if (!(sta->chains & BIT(i)))
+					continue;
+				if (sta->chain_signal_last[i] > max_signal){
+					max_signal = sta->chain_signal_last[i];
+					max_signal_chain = i;
+				}
+				if(printk_ratelimit()){
+					printk(KERN_DEBUG "chain signal last[%d]: %d\n", i, sta->chain_signal_last[i]);
+				}
+			}
+			// turn off lowest if below threshold
+			for (i = 0; i < IEEE80211_MAX_CHAINS; i++) {
+				if (!(sta->chains & BIT(i)))
+					continue;
+				if ((sta->chain_signal_last[i] + local->split_txchains_treshold) < max_signal){
+					result_chainmask &= ~BIT(i);
+				}
+			}
+			if(printk_ratelimit()){
+				printk(KERN_DEBUG "max_signal[%d]: %d\n", max_signal_chain, max_signal);
+			}
+			return result_chainmask;
+		}
+	}
+	return sta->tx_chains;
+}
+EXPORT_SYMBOL(ieee80211_get_tx_chainmask);
-- 
1.8.4

